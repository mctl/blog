## 1、如何进行垃圾回收

v8的垃圾回收策略主要基于分代式回收，将堆内存分为了新生代和老生代。

新生代存放临时对象（函数内部变量，块级作用域变量等），老生代存放长久对象（生命周期长的window、DOM等）。

### 老生代回收方式

老生代采用Mark-Sweep（标记清除）与Mark-Compact（标记整理）结合的策略。

标记-清除将会从根节点（window、dom、栈区变量）开始遍历，并且标记可达的对象，然后进入清除阶段，将不可达对象视为垃圾数据，并清除。

经过标记清除的内存空间往往是不连续的，会出现很多内存碎片，所以需要标记-整理来做内存整理。

整理过程在标记清除的基础上进行修改，清除阶段变为紧缩极端，将活着的对象（可达对象）往一端移动，移动完成后，直接清理掉边界外的内存

因为涉及对象的移动，所以标记整理过程效率比较低，但是可以保证不会有内存碎片

整理过程并非每次垃圾回收都会执行，v8主要使用的仍是标记-清除，在多次标记-清除后连续空间不足时进行内存整理。

整个过程可简化为三步：
1. 标记
2. 垃圾清除
3. 内存整理

### 新生代回收方式

大多数对象都被分配在新生代，这个内存区域较小，但是回收频率又比老生代高很多

所以新生代代回收采用Cheney算法，采用复制的方式实现垃圾回收。

它将堆内存分为两部分（semispace-From与semispace-To）。

在两个semispace中，只有一个被使用，另一个闲置。

当我们分配对象时，先在From中进行分配，当From空间不够都时候进行垃圾回收。

开始垃圾回收算法时，会将From空间中的存活对象全部复制到To区域，然后清空From区，然后From与To角色对调，即完成垃圾回收

整个过程可以简化为三步：
1. 遍历From区标记对象
2. 复制活动对象到To区，清空From区
3. From与To角色对调

在新生代的回收过程中，始终有一半的内存闲置，但由于新生代很小（64位系统下只有32M，另有说法1-8M），所以复制操作的时间效率依然比较理想

此外，当新生代中的对象经过多次回收依然存活，就将其复制到老生代内存中，这个过程被称为对象晋升。

## 2、垃圾回收的优化机制

### 增量标记

为了避免出现js应用逻辑与垃圾回收器的一致性，垃圾回收的3种基本算法都用的逻辑暂停，等垃圾回收完毕再执行js

所以就会造成浏览器一段时间无响应，所以v8使用了增量标记的方式，将完整的回收拆分为多个部分

### 闲时收集
cpu空闲时尝试垃圾回收，以减少可能对代码执行的影响


ps：写完之后就会发现v8的垃圾回收和jvm的垃圾回收基本一样...
